#pragma config(Motor,  port1,           LDB,           tmotorVex393, openLoop)
#pragma config(Motor,  port2,           RDB,           tmotorVex393, openLoop)
#pragma config(Motor,  port3,           LLD,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           LLU,           tmotorVex393, openLoop)
#pragma config(Motor,  port5,           RLD,           tmotorVex393, openLoop)
#pragma config(Motor,  port6,           RLU,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           RDF,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          LDF,           tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Global Variables
bool speedstep_enabled=True;

//Initialise speedstep variables
	int speed;
	int error;
	int integral;
	int derivitive;
	int previous_error[] = {0,0,0,0};

	int test0[] = {0,0,0,0};
	int test1[] = {0,0,0,0};
	int test2[] = {0,0,0,0};
	int test3[] = {0,0,0,0};

	int interval;

//Tune these values
	float Kp = 0.1;
	float Ki = 0;
	float Kd = 0;

	//Speedstep for Drive
	int speedstep(int target,int speed_limit,int sensor_reading,int array_id) //PID for Autonomous Drive
	{
		if (speedstep_enabled == true)
		{
			error = target - sensor_reading;
			integral = integral + error;

			if (error == 0)
			{
				integral = 0;
			}

			if (abs(error) > 40)
			{
				integral = 0;
			}

			derivitive = error - previous_error[array_id];
			previous_error[array_id] = error;
			speed = Kp*error + Ki*integral + Kd*derivitive;

			if (abs(speed) > abs(speed_limit))
			{
				speed = speed_limit;
			}
			return speed;
		}
		else
			{
				return speed_limit;
			}
	}

	void encoder_move(int encoder_distance,int speed)
{
		bool LDB_goal_reached = false;
		bool RDB_goal_reached = false;
		bool LDF_goal_reached = false;
		bool RDF_goal_reached = false;

	while ((LDB_goal_reached == false)||(RDB_goal_reached == false)||(LDF_goal_reached == false)||(RDF_goal_reached == false))
	{
		if (LDB_encoder < encoder_distance)
		{
			motor[LDB] = speedstep(encoder_distance,speed,LDB_encoder,2);
		}
		else
		{
			motor[LDB] = 0;
			LDB_goal_reached=true;
			previous_error[2]=0;
		}

		if (RDB_encoder < encoder_distance)
		{
			motor[RDB] = speedstep(encoder_distance,speed,RDB_encoder,3);
		}
		else
		{
			motor[RDB] = 0;
			RDB_goal_reached=true;
			previous_error[3]=0;
		}

		if (LDF_encoder < encoder_distance)
		{
			motor[LDF] = speedstep(encoder_distance,speed,LDF_encoder,0);
		}
		else
		{
			motor[LDF] = 0;
			LDF_goal_reached=true;
			previous_error[0]=0;
		}

		if (RDF_encoder < encoder_distance)
		{
			motor[RDF] = speedstep(encoder_distance,speed,RDF_encoder,1);
		}
		else
		{
			motor[RDF] = 0;
			RDF_goal_reached=true;
			previous_error[1]=0;
		}
	}
}
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	int amplitude=0;
	int amplitude1=0;
	int amplitude2=0;
	
	int counter=0;
	
	bool consistent = false;
	
	encoder_move(100,127);

	interval = 0.1;

	speedstep_enabled = true;

	while(true)
	{
	//error = target - sensor_reading;

	//first test with Encoder
		if (100-LDF_encoder != 0)
		{
			if (100-LDF_encoder > 0)
			{
				encoder_move(100-LDF_encoder,127);
			}
			if (100-LDF_encoder < 0)
			{
				encoder_move(100-LDF_encoder,-127);
			}
			amplitude2=amplitude1;
			amplitude1=amplitude;
			amplitude=100-LDF_encoder;
		}
		
		//Testing oscillation consistency
		for (i = 0; i == 3; i++)
		{
			if ((abs(amplitude) == abs(amplitude2))||(abs(amplitude)+i == abs(amplitude2))||(abs(amplitude)-i == abs(amplitude2))||(abs(amplitude) == abs(amplitude2)+i)||(abs(amplitude) == abs(amplitude2)-i))
			{
				consistent = true
				break;
			}
		}
		
		if (consistent = true)
		{
			break;
		}
		else
		{
			counter= counter+1;
			if (counter == 3)
			{
				Kp = Kp + interval;
				counter = 0;
			}
		}
	}
	allMotorsOff();
}
